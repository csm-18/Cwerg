-- Simple JPEG Decoder loosely based on
-- https://keyj.emphy.de/nanojpeg/
-- More Info
-- https://github.com/corkami/formats/blob/master/image/jpeg.md
-- For Huffman codes
-- https://www.ece.ucdavis.edu/cerl/wp-content/uploads/sites/14/2015/09/GenHuffCodes.pdf
-- https://www.youtube.com/watch?v=CPT4FSkFUgs
module:

import BS = bytestream

import fmt

-- To enable debug logging make sure the next macro is called `debug#`
-- To enable debug logging make sure the second macro is called `debug#`
macro debug# STMT_LIST($parts EXPR_LIST_REST)[]:
      fmt::print#($parts)

macro xdebug# STMT_LIST($parts EXPR_LIST_REST)[]:


global W1 s32 = 2841
global W2 s32 = 2676
global W3 s32 = 2408
global W5 s32 = 1609
global W6 s32 = 1108
global W7 s32 = 565

-- updates blk in place
fun RowIDCT(blk ^![8]s32) void:
    let! x1 = blk^[4] << 11
    let! x2 = blk^[6]
    let! x3 = blk^[2]
    let! x4 = blk^[1]
    let! x5 = blk^[7]
    let! x6 = blk^[5]
    let! x7 = blk^[3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = blk^[0] << 3
        for i = 0, 8_u32, 1:
            set blk^[i] = t
        return
    let! x0 = (blk^[0] << 11) + 128
    let! x8 = (x4 + x5) * W7
    set x4 = x8 + x4 * (W1 - W7)
    set x5 = x8 - x5 * (W1 + W7)
    set x8 = (x6 + x7) * W3
    set x6 = x8 - x6 * (W3 - W5)
    set x7 = x8 - x7 * (W3 + W5)
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6
    set x2 = x1 - x2 * (W2 + W6)
    set x3 = x1 + x3 * (W2 - W6)
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set blk^[0] = (x7 + x1) >> 8
    set blk^[1] = (x3 + x2) >> 8
    set blk^[2] = (x0 + x4) >> 8
    set blk^[3] = (x8 + x6) >> 8
    set blk^[4] = (x8 - x6) >> 8
    set blk^[5] = (x0 - x4) >> 8
    set blk^[6] = (x3 - x2) >> 8
    set blk^[7] = (x7 - x1) >> 8

-- clamp x to [0:255]
fun ClampU8(x s32) u8:
    cond:
        case x < 0:
            return 0
        case x >= 0xff:
            return 0xff
        case true:
            return as(x, u8)


fun ColIDCT(blk ^[8*8]s32, out slice!(u8), stride uint) void:
    let! x1 = blk^[8*4] << 8
    let! x2 = blk^[8*6]
    let! x3 = blk^[8*2]
    let! x4 = blk^[8*1]
    let! x5 = blk^[8*7]
    let! x6 = blk^[8*5]
    let! x7 = blk^[8*3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = ClampU8(((blk^[0] + 32) >> 6) + 128)
        for i = 0, 8_u32, 1:
            set out[i * 8] = t
        return
    let! x0 = (blk^[0] << 8) + 8192
    let! x8 = (x4 + x5) * W7 + 4
    set x4 = (x8 + x4 * (W1 - W7)) >> 3
    set x5 = (x8 - x5 * (W1 + W7)) >> 3
    set x8 = (x6 + x7) * W3 + 4
    set x6 = (x8 - x6 * (W3 - W5)) >> 3
    set x7 = (x8 - x7 * (W3 + W5)) >> 3
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6 + 4
    set x2 = (x1 - x2 * (W2 + W6)) >> 3
    set x3 = (x1 + x3 * (W2 - W6)) >> 3
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set out[0 * stride] = ClampU8(((x7 + x1) >> 14) + 128)
    set out[1 * stride] = ClampU8(((x3 + x2) >> 14) + 128)
    set out[2 * stride] = ClampU8(((x0 + x4) >> 14) + 128)
    set out[3 * stride] = ClampU8(((x8 + x6) >> 14) + 128)
    set out[4 * stride] = ClampU8(((x8 - x6) >> 14) + 128)
    set out[5 * stride] = ClampU8(((x0 - x4) >> 14) + 128)
    set out[6 * stride] = ClampU8(((x3 - x2) >> 14) + 128)
    set out[7 * stride] = ClampU8(((x7 - x1) >> 14) + 128)



-- for huffman decoding
rec BitStream:
    buf slice(u8)
    offset uint
    -- contains the next up to 8 bits from the stream
    -- the exact number is bits_count
    bits_cache u8
    bits_count u8
    -- end-of-stream flag - once set it will not be cleared
    eos bool

pub fun GetNextBit(bs ^!BitStream) u16:
    let! bits_count u8 = bs^.bits_count
    let! bits_cache u8 = bs^.bits_cache
    if bits_count == 0:
        if bs^.offset == len(bs^.buf):
            set bs^.eos = true
            return 0
        set bits_cache = bs^.buf[bs^.offset]
        -- debug#("new cache: ", wrap_as(bits_cache, fmt::u8_hex), "\n")
        set bs^.offset += 1
        set bits_count = 8
        if bits_cache == 0xff:
            if bs^.offset == len(bs^.buf):
                set bs^.eos = true
                return 0
            let zeros = bs^.buf[bs^.offset]
            if zeros != 0:
                set bs^.eos = true
                return 0
            set bs^.offset += 1
        set bs^.bits_cache = bits_cache

    set bits_count -= 1
    let out = as((bits_cache >> bits_count) and 1 , u16)
    set bs^.bits_count = bits_count
    return out

rec HuffmanTree:
    counts [16]u8
    symbols [256]u8
    num_symbols u8
    min_code [16]u16
    max_code [16]u16
    val_ptr [16]u8

global BAD_SYMBOL = 0xffff_u16


fun NextSymbol(bs ^!BitStream, ht ^HuffmanTree) u16:
    let! offset u16 = GetNextBit(bs)
    for level = 0, len(ht^.counts), 1:
        let mc =  ht^.max_code[level]
        if offset <= mc && mc != 0xffff:
            set offset += as(ht^.val_ptr[level], u16) - ht^.min_code[level]
            debug#("huffman level=", level,  " offset=", offset, " symbol=", ht^.symbols[offset], "\n")
            return as(ht^.symbols[offset],u16)
        set offset <<= 1
        set offset += GetNextBit(bs)
    return BAD_SYMBOL

-- not we rely on wrap around arithmetic
fun GetVal(bs ^!BitStream, num_bits u16) s16:
    let bits = as(num_bits, s32)
    let! out s32 = 0
    for i = 0, bits, 1:
        set out <<= 1
        set out or= as(GetNextBit(bs), s32)
    -- note: signed shift
    if out < 1 << (bits - 1):
        set out += ((-1) << bits) + 1
    return as(out, s16)

rec AppInfo:
    version_major u8
    version_minor u8
    units u8
    density_x u16
    density_y u16
    thumbnail_w u8
    thumbnail_h u8




rec Component:
    cid u8
    ssx u32
    ssy u32
    qtsel u8

    -- image dimensions in pixels
    width u32
    height u32
    stride u32
    dctabsel u8
    actabsel u8

rec FrameInfo:
    width u32
    height u32
    ncomp u8

    -- macro block dimensions in pixels (e.g. 8x8)
    mbsizex u32
    mbsizey u32
    -- image dimension measure in macro blocks
    mbwidth u32
    mbheight u32

    comp [3]Component




pub @wrapped type Success = void
pub global SuccessVal = wrap_as(void, Success)

pub @wrapped type CorruptionError = void
pub global CorruptionErrorVal = wrap_as(void, CorruptionError)

pub @wrapped type UnsupportedError = void
pub global UnsupportedErrorVal = wrap_as(void, UnsupportedError)


fun div_roundup(a u32, b u32) u32:
    return (a + b -1) / b

fun DecodeHufmanTable(chunk slice(u8), huffman_trees ^![2][2]HuffmanTree)
    union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    let kind = BS::FrontU8Unchecked(&!data)
    if kind and 0xec != 0:
        return CorruptionErrorVal
    let pos = kind and 3
    if pos > 1:
        return UnsupportedErrorVal
    -- 0 means dc
    let is_ac = (kind and 0x10) >> 4
    let ht ^!HuffmanTree = &!huffman_trees^[is_ac][pos]
    let counts = BS::FrontSliceUnchecked(&!data, 16)
    let! total = 0_uint
    for i = 0, 16_s32, 1:
        set total += as(counts[i], uint)
        set ht^.counts[i] = counts[i]
    if len(data) < total:
        return  BS::OutOfBoundsErrorVal
    for i = 0, total, 1:
        set ht^.symbols[i] = data[i]
    if total > 255:
        return CorruptionErrorVal
    set ht^.num_symbols = as(total, u8)
    do BS::SkipUnchecked(&!data, total)
    debug#("Hufman total codes[", is_ac, ",", pos, "]: ", total, "\n")
    let! acc u16 = 0
    let! code u16 = 0
    for i = 0, 16_s32, 1:
        let num u16 = as(counts[i], u16)
        if num == 0:
            set ht^.min_code[i] = 0
            set ht^.max_code[i] = 0xffff_u16
            set ht^.val_ptr[i] = 0
        else:
            set ht^.min_code[i] = code
            set ht^.max_code[i] = code + num -1
            set ht^.val_ptr[i] = as(acc, u8)
            set acc += num
            set code += num
        set code <<= 1

    return SuccessVal

fun DecodeQuantizationTable(chunk slice(u8),  qtab ^![4][64]u8)
    union(u8, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    let! qtavail u8 = 0
    while len(data) >= 65:
        let t = data[0]
        if t and 0xfc != 0:
            return CorruptionErrorVal
        debug#("processing qt: ", t, "\n")
        set qtavail or= 1 << t
        for i = 0, 64_u32, 1:
            set qtab^[t][i] = data[i + 1]
        do BS::SkipUnchecked(&!data, 65)
    if len(data) != 0:
        return CorruptionErrorVal
    return qtavail

fun DecodeRestartInterval(chunk slice(u8))
      union(u16, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet interval u16 = BS::FrontBeU16(&!data), err:
        return err
    debug#("restart interval: ", interval, "\n")
    return interval

fun DecodeAppInfo(chunk slice(u8), app_info ^!AppInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    if len(data) < 14:
        return CorruptionErrorVal
    if data[0] != 'J' || data[1] != 'F' || data[2] != 'I'  || data[3] != 'F' || data[4] != 0:
        return CorruptionErrorVal
    do BS::SkipUnchecked(&!data, 5)
    set app_info^.version_major = BS::FrontU8Unchecked(&!data)
    set app_info^.version_minor = BS::FrontU8Unchecked(&!data)
    set app_info^.units = BS::FrontU8Unchecked(&!data)
    set app_info^.density_x = BS::FrontBeU16Unchecked(&!data)
    set app_info^.density_y = BS::FrontBeU16Unchecked(&!data)
    set app_info^.thumbnail_w = BS::FrontU8Unchecked(&!data)
    set app_info^.thumbnail_h = BS::FrontU8Unchecked(&!data)
    debug#("AppInfo: ", app_info^.version_major, ".", app_info^.version_minor, "\n")
    return SuccessVal

fun DecodeStartOfFrame(chunk slice(u8), out ^!FrameInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet format u8 = BS::FrontU8(&!data), err:
        return err
    if format != 8:
        debug#("unsupported format: ", format, "\n")
        return UnsupportedErrorVal
    trylet height u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.height = as(height, u32)
    trylet width u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.width = as(width, u32)
    trylet ncomp u8  = BS::FrontU8(&!data), err:
            return err
    set out^.ncomp = ncomp
    if ncomp != 1 &&  ncomp != 3:
        debug#("unsupported ncomp: ", ncomp, "\n")
        return UnsupportedErrorVal

    debug#("frame: ", width, "x", height, " ncomp: ", ncomp, "\n")
    let! ssxmax u32 = 0
    let! ssymax u32 = 0
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        tryset comp^.cid = BS::FrontU8(&!data), err:
            return err

        trylet ss u8 = BS::FrontU8(&!data), err:
            return err
        let ssx = as(ss >> 4, u32)
        let ssy = as(ss and 0xf, u32)
        -- ssy must be a power of two
        if ssx == 0 || ssy == 0 || ssy and (ssy - 1) != 0:
            debug#("bad ss: ", ssx, "x", ssy, "\n")
            return CorruptionErrorVal

         debug#("comp: ", i, " ", comp^.cid, " ", ssx, "x", ssy, "\n")

        set comp^.ssx = ssx
        set comp^.ssy = ssy
        set ssxmax max= ssx
        set ssymax max= ssy

        trylet! qtsel u8 = BS::FrontU8(&!data), err:
            return err
        if qtsel and 0xfc!= 0:
            debug#("bad qtsel: ", qtsel, "\n")
            return CorruptionErrorVal
        set comp^.qtsel = qtsel

    if ncomp == 1:
        set ssxmax = 1
        set ssymax = 1
        set out^.comp[0].ssx = 1
        set out^.comp[0].ssy = 1

    let mbsizex  u32 = as(ssxmax, u32) * 8
    let mbsizey  u32 = as(ssymax, u32) * 8

    set out^.mbsizex = mbsizex
    set out^.mbsizey = mbsizey
    set out^.mbwidth = div_roundup(out^.width, mbsizex)
    set out^.mbheight = div_roundup(out^.height, mbsizey)
    debug#("mbsize: ", mbsizex, "x", mbsizey,  " mbdim: ", out^.mbwidth, "x", out^.mbheight, "\n")
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        set comp^.width = div_roundup(out^.width * comp^.ssx, ssxmax)
        set comp^.height = div_roundup(out^.height * comp^.ssy, ssymax)
        set comp^.stride = out^.mbwidth * comp^.ssx * 8
        if comp^.width < 3 && comp^.ssx != ssxmax:
            debug#("bad width: ", comp^.width, "\n")
            return CorruptionErrorVal
        if comp^.height < 3 && comp^.ssy != ssymax:
            debug#("bad height: ", comp^.height, "\n")
            return CorruptionErrorVal
        debug#("comp: ", i, " ", comp^.width, "x", comp^.height, " stride:", comp^.stride, "\n")

    return SuccessVal

fun DecodeScan(chunk slice(u8), frame_info ^!FrameInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet ncomp u8  = BS::FrontU8(&!data), err:
            return err
    if ncomp != frame_info^.ncomp:
        return UnsupportedErrorVal

    for i = 0, ncomp, 1:
        if len(data) < 2:
            return  BS::OutOfBoundsErrorVal
        let comp ^!Component = &!(frame_info^.comp[i])
        if  data[0] != comp^.cid:
            return CorruptionErrorVal
        let tabsel = data[1]
        if tabsel and 0xee != 0:
             return CorruptionErrorVal
        set comp^.dctabsel = (tabsel >> 4) and 1
        set comp^.actabsel = tabsel and 1
        debug#("tabsel[", comp^.cid,"]: ",  comp^.dctabsel, ".",comp^.actabsel, "\n")
        do BS::SkipUnchecked(&!data, 2)
        if len(data) < 3:
            return  BS::OutOfBoundsErrorVal

    if data[0] != 0 || data[1] != 63 || data[2] != 0:
        return UnsupportedErrorVal
    do BS::SkipUnchecked(&!data, 3)
    debug#(">>>>>>> ", data[0], "\n")
    return SuccessVal


-- returns new dc value on success
fun  DecodeBlock(bs ^!BitStream, dc_tab ^HuffmanTree, ac_tab ^HuffmanTree, last_dc s16)
    union(s16, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    let dc_code = NextSymbol(bs,  dc_tab)
    let dc_val s16 = GetVal(bs, dc_code and 0xf)
    debug#("dc=", dc_val, "\n")
    let! coeff u16 = 0
    while true:
        let ac_code = NextSymbol(bs,  ac_tab)
        let extra_bits = ac_code and 0xf
        for i = 0, extra_bits, 1:
            do GetNextBit(bs)
        if ac_code == 0:
            break
        set coeff += (ac_code >> 4) + 1
        if coeff >= 63:
          break
    return last_dc + dc_val

fun DecodeMacroBlocksHuffman(chunk slice(u8), frame_info ^FrameInfo,  huffman_trees ^[2][2]HuffmanTree)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    debug#("Decode blocks\n")
    @ref let! bs = BitStream{chunk}
    let! dc_last = [3]s16{0, 0, 0}
    for m = 0, frame_info^.mbwidth * frame_info^.mbheight, 1:
        for c = 0, frame_info^.ncomp, 1:
            let comp ^Component = &frame_info^.comp[c]
            let dc_tab ^HuffmanTree = &huffman_trees^[0][comp^.dctabsel]
            let ac_tab ^HuffmanTree = &huffman_trees^[1][comp^.actabsel]
            for y = 0, comp^.ssy, 1:
                for x = 0, comp^.ssx, 1:
                    -- debug#("Block: ", m, " comp=", c, " x=", x, " y=", y, "\n")
                    debug#("Block ===================\n")
                    tryset dc_last[c] = DecodeBlock(&!bs, dc_tab, ac_tab, dc_last[c]), err:
                        return err
                    if m == 1000:
                        return UnsupportedErrorVal

    return SuccessVal

pub fun DecodeImage(a_data slice(u8))
        union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    debug#("DecodeImage: ", len(a_data), "\n")
    @ref let! app_info AppInfo = undef
    @ref let! frame_info FrameInfo = undef
    @ref let! huffman_trees [2][2]HuffmanTree = undef
    @ref let! quantization_tab [4][64]u8 = undef
    let! qt_avail_bits u8 = 0
    let! restart_interval u16 = 0
    @ref let! data = a_data
    trylet magic u16 = BS::FrontBeU16(&!data), err:
        return err
    if magic != 0xffd8:
        debug#("bad magic: ", wrap_as(magic, fmt::u16_hex), "\n")
        return  CorruptionErrorVal

    while true:
        trylet chunk_kind u16 = BS::FrontBeU16(&!data), err:
            return err
        trylet chunk_length u16 = BS::FrontBeU16(&!data), err:
            return err

        debug#("CHUNK: ", wrap_as(chunk_kind, fmt::u16_hex), " ", chunk_length, "\n")
        trylet chunk_slice slice(u8) = BS::FrontSlice(&!data, as(chunk_length - 2, uint)), err:
            return err
        cond:
            case chunk_kind == 0xffe0:
                trylet dummy Success = DecodeAppInfo(chunk_slice, &!app_info), err:
                    return err
            case chunk_kind == 0xffc0:
                trylet dummy Success = DecodeStartOfFrame(chunk_slice, &!frame_info), err:
                    return err
            case chunk_kind == 0xffc4:
                trylet dummy Success = DecodeHufmanTable(chunk_slice, &!huffman_trees), err:
                    return err
            case chunk_kind == 0xffdb:
                tryset qt_avail_bits = DecodeQuantizationTable(chunk_slice, &!quantization_tab), err:
                    return err
            case chunk_kind == 0xffdd:
                tryset restart_interval = DecodeRestartInterval(chunk_slice), err:
                    return err
            case chunk_kind == 0xffda:
                -- start of scan chunk, huffman encoded image data follows
                trylet dummy Success = DecodeScan(chunk_slice, &!frame_info), err:
                    return err
                trylet dummy2 Success = DecodeMacroBlocksHuffman(data, &frame_info, &huffman_trees), err:
                    return err
                break
            case chunk_kind == 0xfffe:
                debug#("chunk ignored\n")
            case chunk_kind and 0xfff0 == 0xffe0:
                debug#("chunk ignored\n")
            case true:
                return UnsupportedErrorVal

    debug#("DecodeImage complete\n")
    return SuccessVal