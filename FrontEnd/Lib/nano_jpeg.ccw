module:

import BS = bytestream

global W1 s32 = 2841
global W2 s32 = 2676
global W3 s32 = 2408
global W5 s32 = 1609
global W6 s32 = 1108
global W7 s32 = 565

-- updates blk in place
fun RowIDCT(blk ^![8]s32) void:
    let! x1 = blk^[4] << 11
    let! x2 = blk^[6]
    let! x3 = blk^[2]
    let! x4 = blk^[1]
    let! x5 = blk^[7]
    let! x6 = blk^[5]
    let! x7 = blk^[3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = blk^[0] << 3
        for i = 0, 8_u32, 1:
            set blk^[i] = t
        return
    let! x0 = (blk^[0] << 11) + 128
    let! x8 = (x4 + x5) * W7
    set x4 = x8 + x4 * (W1 - W7)
    set x5 = x8 - x5 * (W1 + W7)
    set x8 = (x6 + x7) * W3
    set x6 = x8 - x6 * (W3 - W5)
    set x7 = x8 - x7 * (W3 + W5)
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6
    set x2 = x1 - x2 * (W2 + W6)
    set x3 = x1 + x3 * (W2 - W6)
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set blk^[0] = (x7 + x1) >> 8
    set blk^[1] = (x3 + x2) >> 8
    set blk^[2] = (x0 + x4) >> 8
    set blk^[3] = (x8 + x6) >> 8
    set blk^[4] = (x8 - x6) >> 8
    set blk^[5] = (x0 - x4) >> 8
    set blk^[6] = (x3 - x2) >> 8
    set blk^[7] = (x7 - x1) >> 8

-- clamp x to [0:255]
fun ClampU8(x s32) u8:
    cond:
        case x < 0:
            return 0
        case x >= 0xff:
            return 0xff
        case true:
            return as(x, u8)


fun ColIDCT(blk ^[8*8]s32, out slice!(u8), stride uint) void:
    let! x1 = blk^[8*4] << 8
    let! x2 = blk^[8*6]
    let! x3 = blk^[8*2]
    let! x4 = blk^[8*1]
    let! x5 = blk^[8*7]
    let! x6 = blk^[8*5]
    let! x7 = blk^[8*3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = ClampU8(((blk^[0] + 32) >> 6) + 128)
        for i = 0, 8_u32, 1:
            set out[i * 8] = t
        return
    let! x0 = (blk^[0] << 8) + 8192
    let! x8 = (x4 + x5) * W7 + 4
    set x4 = (x8 + x4 * (W1 - W7)) >> 3
    set x5 = (x8 - x5 * (W1 + W7)) >> 3
    set x8 = (x6 + x7) * W3 + 4
    set x6 = (x8 - x6 * (W3 - W5)) >> 3
    set x7 = (x8 - x7 * (W3 + W5)) >> 3
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6 + 4
    set x2 = (x1 - x2 * (W2 + W6)) >> 3
    set x3 = (x1 + x3 * (W2 - W6)) >> 3
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set out[0 * stride] = ClampU8(((x7 + x1) >> 14) + 128)
    set out[1 * stride] = ClampU8(((x3 + x2) >> 14) + 128)
    set out[2 * stride] = ClampU8(((x0 + x4) >> 14) + 128)
    set out[3 * stride] = ClampU8(((x8 + x6) >> 14) + 128)
    set out[4 * stride] = ClampU8(((x8 - x6) >> 14) + 128)
    set out[5 * stride] = ClampU8(((x0 - x4) >> 14) + 128)
    set out[6 * stride] = ClampU8(((x3 - x2) >> 14) + 128)
    set out[7 * stride] = ClampU8(((x7 - x1) >> 14) + 128)

rec Code:
    bits u8
    code u8

rec Component:
    cid u8
    ssx u8
    ssy u8
    qtsel u8

    width u32
    height u32
    stride s32
    actabsel s32
    dctabsel s32
    dcpred s32

rec Context:
    width u16
    height u16
    ncomp u8
    mbsizex u8
    mbsizey u8

    size s32
    length s32

    mbwidth s32
    mbheight s32

    comp [3]Component
    qtab [64][4]u8



pub @wrapped type Success = void
pub global SuccessVal = wrap_as(void, Success)

pub @wrapped type CorruptionError = void
pub global CorruptionErrorVal = wrap_as(void, CorruptionError)

pub @wrapped type UnsupportedError = void
pub global UnsupportedErrorVal = wrap_as(void, UnsupportedError)



fun DecodeScan(data ^!slice(u8))
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
   trylet l u16 = BS::FrontBeU16(data), err:
      return err
   return SuccessVal


fun DecodeStartOfFrame(data ^!slice(u8), out ^!Context)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    let start_size = len(data^)
    trylet l u16 = BS::FrontBeU16(data), err:
        return err
    trylet format u8 = BS::FrontU8(data), err:
        return err
    if format != 8:
        return UnsupportedErrorVal
    tryset out^.height = BS::FrontBeU16(data), err:
            return err
    tryset out^.width = BS::FrontBeU16(data), err:
            return err
    trylet ncomp u8  = BS::FrontU8(data), err:
            return err
    set out^.ncomp = ncomp
    if ncomp != 1 &&  ncomp != 3:
        return UnsupportedErrorVal

    let! ssxmax u8 = 0
    let! ssymax u8 = 0
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        tryset comp^.cid = BS::FrontU8(data), err:
            return err
        trylet ss u8 = BS::FrontU8(data), err:
            return err
        let ssx = ss >> 4
        let ssy = ss and 0xf
        -- ssy must be a power of two
        if ssx == 0 || ssy == 0 || ssy and (ssy - 1) != 0:
            return CorruptionErrorVal

        set comp^.ssx = ssx
        set comp^.ssy = ssy
        set ssxmax max= ssx
        set ssymax max= ssy

        trylet! qtsel u8 = BS::FrontU8(data), err:
            return err
        set qtsel and= 0xfc
        if qtsel == 0:
            return CorruptionErrorVal
        set comp^.qtsel = qtsel and 0xfc

    if ncomp == 1:
        set ssxmax = 1
        set ssymax =1
        set out^.comp[0].ssx = 1
        set out^.comp[0].ssy = 1

    set out^.mbsizex = ssxmax << 3
    set out^.mbsizey = ssymax << 3

pub fun DecodeImage(a_data slice(u8))
        union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let ctx Context = undef
    @ref let! data = a_data
    trylet magic u16 = BS::FrontBeU16(&!data), err:
        return err
    if magic != 0xffda:
        return  CorruptionErrorVal

    while true:
        trylet kind u16 = BS::FrontBeU16(&!data), err:
            return err
        cond:
            case kind == 0xffc0:

            case kind == 0xffc4:
            case kind == 0xffdb:
            case kind == 0xffdd:
            case kind == 0xffda:
            -- TBD
            case kind == 0xfffe:
                trylet l u16 = BS::FrontBeU16(&!data), err:
                    return err
                do BS::Skip(&!data, as(l, uint))
            -- TBD
            case kind and 0xfff0 == 0xffe0:
                trylet l u16 = BS::FrontBeU16(&!data), err:
                    return err
                do BS::Skip(&!data, as(l, uint))
            case true:
                return UnsupportedErrorVal


    return SuccessVal