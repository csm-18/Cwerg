--  Simple JPEG Decoder loosely based on
-- https://github.com/corkami/formats/blob/master/image/jpeg.md
module:

import BS = bytestream

import fmt


macro xdebug# STMT_LIST($parts EXPR_LIST_REST)[]:
    fmt::print_list#($parts)

macro debug# STMT_LIST($parts EXPR_LIST_REST)[]:

global W1 s32 = 2841
global W2 s32 = 2676
global W3 s32 = 2408
global W5 s32 = 1609
global W6 s32 = 1108
global W7 s32 = 565

-- updates blk in place
fun RowIDCT(blk ^![8]s32) void:
    let! x1 = blk^[4] << 11
    let! x2 = blk^[6]
    let! x3 = blk^[2]
    let! x4 = blk^[1]
    let! x5 = blk^[7]
    let! x6 = blk^[5]
    let! x7 = blk^[3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = blk^[0] << 3
        for i = 0, 8_u32, 1:
            set blk^[i] = t
        return
    let! x0 = (blk^[0] << 11) + 128
    let! x8 = (x4 + x5) * W7
    set x4 = x8 + x4 * (W1 - W7)
    set x5 = x8 - x5 * (W1 + W7)
    set x8 = (x6 + x7) * W3
    set x6 = x8 - x6 * (W3 - W5)
    set x7 = x8 - x7 * (W3 + W5)
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6
    set x2 = x1 - x2 * (W2 + W6)
    set x3 = x1 + x3 * (W2 - W6)
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set blk^[0] = (x7 + x1) >> 8
    set blk^[1] = (x3 + x2) >> 8
    set blk^[2] = (x0 + x4) >> 8
    set blk^[3] = (x8 + x6) >> 8
    set blk^[4] = (x8 - x6) >> 8
    set blk^[5] = (x0 - x4) >> 8
    set blk^[6] = (x3 - x2) >> 8
    set blk^[7] = (x7 - x1) >> 8

-- clamp x to [0:255]
fun ClampU8(x s32) u8:
    cond:
        case x < 0:
            return 0
        case x >= 0xff:
            return 0xff
        case true:
            return as(x, u8)


fun ColIDCT(blk ^[8*8]s32, out slice!(u8), stride uint) void:
    let! x1 = blk^[8*4] << 8
    let! x2 = blk^[8*6]
    let! x3 = blk^[8*2]
    let! x4 = blk^[8*1]
    let! x5 = blk^[8*7]
    let! x6 = blk^[8*5]
    let! x7 = blk^[8*3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = ClampU8(((blk^[0] + 32) >> 6) + 128)
        for i = 0, 8_u32, 1:
            set out[i * 8] = t
        return
    let! x0 = (blk^[0] << 8) + 8192
    let! x8 = (x4 + x5) * W7 + 4
    set x4 = (x8 + x4 * (W1 - W7)) >> 3
    set x5 = (x8 - x5 * (W1 + W7)) >> 3
    set x8 = (x6 + x7) * W3 + 4
    set x6 = (x8 - x6 * (W3 - W5)) >> 3
    set x7 = (x8 - x7 * (W3 + W5)) >> 3
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6 + 4
    set x2 = (x1 - x2 * (W2 + W6)) >> 3
    set x3 = (x1 + x3 * (W2 - W6)) >> 3
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set out[0 * stride] = ClampU8(((x7 + x1) >> 14) + 128)
    set out[1 * stride] = ClampU8(((x3 + x2) >> 14) + 128)
    set out[2 * stride] = ClampU8(((x0 + x4) >> 14) + 128)
    set out[3 * stride] = ClampU8(((x8 + x6) >> 14) + 128)
    set out[4 * stride] = ClampU8(((x8 - x6) >> 14) + 128)
    set out[5 * stride] = ClampU8(((x0 - x4) >> 14) + 128)
    set out[6 * stride] = ClampU8(((x3 - x2) >> 14) + 128)
    set out[7 * stride] = ClampU8(((x7 - x1) >> 14) + 128)

rec Code:
    bits u8
    code u8

rec Component:
    cid u8
    ssx u32
    ssy u32
    qtsel u8

    width u32
    height u32
    stride u32


rec Context:
    width u32
    height u32
    ncomp u8

    mbsizex u32
    mbsizey u32
    mbwidth u32
    mbheight u32

    size s32
    length s32

    comp [3]Component
    qtab [64][4]u8



pub @wrapped type Success = void
pub global SuccessVal = wrap_as(void, Success)

pub @wrapped type CorruptionError = void
pub global CorruptionErrorVal = wrap_as(void, CorruptionError)

pub @wrapped type UnsupportedError = void
pub global UnsupportedErrorVal = wrap_as(void, UnsupportedError)



fun DecodeScan(data ^!slice(u8))
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
   trylet l u16 = BS::FrontBeU16(data), err:
      return err
   return SuccessVal


fun div_roundup(a u32, b u32) u32:
    return (a + b -1) / b

fun DecodeHufmanTable(chunk slice(u8),  vlctab ^[4][65536]Code)
    union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    while len(data) >= 17:
        let kind = BS::FrontU8Unchecked(&!data)
        if kind and 0xec != 0:
            return CorruptionErrorVal
        if kind and 0x02 != 0:
            return UnsupportedErrorVal
        -- combined DC/AC + tableid value
        let pos u32 = ((as(kind, u32) and 0x1f) >> 3) or (as(kind, u32) and 1)
        let counts = BS::FrontSliceUnchecked(&!data, 16)
        let! remain s32 = 65536
        let! spread s32 = 65536
        for codelen = 0, 16_s32, 1:
            set spread >>= 1
            let n = as(counts[codelen], s32)
            if n == 0:
                continue
            set remain -= n << (15 - codelen)
            if remain < 0:
                return CorruptionErrorVal
            let words = BS::FrontSlice(&!data, as(n, uint))
            for i = 0, n, 1:
                -- TODO
                return SuccessVal

fun DecodeQuantizationTable(chunk slice(u8),  qtab ^![4][64]u8)
    union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    let! qtavail u32 = 0
    while len(data) >= 65:
        let t = data[0]
        if t and 0xfc != 0:
            return CorruptionErrorVal
        set qtavail or= 1 << as(t, u32)
        for i = 0, 64_u32, 1:
            set qtab^[t][i] = data[i + 1]
        do BS::SkipUnchecked(&!data, 65)
    if len(data) != 0:
        return CorruptionErrorVal
    return SuccessVal

fun DecodeRestartInterval(chunk slice(u8),  qtab ^![4][64]u8)
      union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk

    trylet interval u16 = BS::FrontBeU16(&!data), err:
        return err
    -- TODO
    return SuccessVal



fun DecodeStartOfFrame(chunk slice(u8), out ^!Context)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet format u8 = BS::FrontU8(&!data), err:
        return err
    if format != 8:
        return UnsupportedErrorVal
    trylet height u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.height = as(height, u32)
    trylet width u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.width = as(width, u32)
    trylet ncomp u8  = BS::FrontU8(&!data), err:
            return err
    set out^.ncomp = ncomp
    if ncomp != 1 &&  ncomp != 3:
        return UnsupportedErrorVal

    let! ssxmax u32 = 0
    let! ssymax u32 = 0
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        tryset comp^.cid = BS::FrontU8(&!data), err:
            return err
        trylet ss u8 = BS::FrontU8(&!data), err:
            return err
        let ssx = as(ss >> 4, u32)
        let ssy = as(ss and 0xf, u32)
        -- ssy must be a power of two
        if ssx == 0 || ssy == 0 || ssy and (ssy - 1) != 0:
            return CorruptionErrorVal

        set comp^.ssx = ssx
        set comp^.ssy = ssy
        set ssxmax max= ssx
        set ssymax max= ssy

        trylet! qtsel u8 = BS::FrontU8(&!data), err:
            return err
        set qtsel and= 0xfc
        if qtsel == 0:
            return CorruptionErrorVal
        set comp^.qtsel = qtsel and 0xfc

    if ncomp == 1:
        set ssxmax = 1
        set ssymax = 1
        set out^.comp[0].ssx = 1
        set out^.comp[0].ssy = 1

    let mbsizex  u32 = as(ssxmax, u32) * 8
    let mbsizey  u32 = as(ssymax, u32) * 8

    set out^.mbsizex = mbsizex
    set out^.mbsizey = mbsizey
    set out^.mbwidth = div_roundup(out^.width, mbsizex)
    set out^.mbheight = div_roundup(out^.height, mbsizey)
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        set comp^.width = div_roundup(out^.width * comp^.ssx, ssxmax)
        set comp^.height = div_roundup(out^.height * comp^.ssy, ssymax)
        set comp^.stride = out^.mbwidth * comp^.ssx * 8
        if comp^.width < 3 && comp^.ssx != ssxmax:
            return CorruptionErrorVal
        if comp^.height < 3 && comp^.ssy != ssymax:
            return CorruptionErrorVal
    return SuccessVal

pub fun DecodeImage(a_data slice(u8))
        union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! ctx Context = undef
    @ref let! data = a_data
    trylet magic u16 = BS::FrontBeU16(&!data), err:
        return err
    if magic != 0xffda:
        return  CorruptionErrorVal

    while true:
        trylet chunk_kind u16 = BS::FrontBeU16(&!data), err:
            return err
        trylet chunk_length u16 = BS::FrontBeU16(&!data), err:
            return err

        debug#(wrap_as(chunk_kind, fmt::u16_hex), " ", chunk_length, "\n")
        trylet chunk_slice slice(u8) = BS::FrontSlice(&!data, as(chunk_length, uint)), err:
            return err
        cond:
            case chunk_kind == 0xffc0:
                trylet dummy Success = DecodeStartOfFrame(chunk_slice, &!ctx), err:
                    return err
            case chunk_kind == 0xffc4:
            case chunk_kind == 0xffdb:
            case chunk_kind == 0xffdd:
            case chunk_kind == 0xffda:
            -- TBD
            case chunk_kind == 0xfffe:
            -- TBD
            case chunk_kind and 0xfff0 == 0xffe0:
            case true:
                return UnsupportedErrorVal


    return SuccessVal