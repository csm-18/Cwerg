-- Simple JPEG Decoder loosely based on
-- https://keyj.emphy.de/nanojpeg/
-- More Info
-- https://github.com/corkami/formats/blob/master/image/jpeg.md
-- For Huffman codes
-- https://www.ece.ucdavis.edu/cerl/wp-content/uploads/sites/14/2015/09/GenHuffCodes.pdf
module:

import BS = bytestream

import fmt

-- To enable debug logging make sure the next macro is called `debug#`
-- To enable debug logging make sure the second macro is called `debug#`
macro debug# STMT_LIST($parts EXPR_LIST_REST)[]:
      fmt::print#($parts)

macro xdebug# STMT_LIST($parts EXPR_LIST_REST)[]:


global W1 s32 = 2841
global W2 s32 = 2676
global W3 s32 = 2408
global W5 s32 = 1609
global W6 s32 = 1108
global W7 s32 = 565

-- updates blk in place
fun RowIDCT(blk ^![8]s32) void:
    let! x1 = blk^[4] << 11
    let! x2 = blk^[6]
    let! x3 = blk^[2]
    let! x4 = blk^[1]
    let! x5 = blk^[7]
    let! x6 = blk^[5]
    let! x7 = blk^[3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = blk^[0] << 3
        for i = 0, 8_u32, 1:
            set blk^[i] = t
        return
    let! x0 = (blk^[0] << 11) + 128
    let! x8 = (x4 + x5) * W7
    set x4 = x8 + x4 * (W1 - W7)
    set x5 = x8 - x5 * (W1 + W7)
    set x8 = (x6 + x7) * W3
    set x6 = x8 - x6 * (W3 - W5)
    set x7 = x8 - x7 * (W3 + W5)
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6
    set x2 = x1 - x2 * (W2 + W6)
    set x3 = x1 + x3 * (W2 - W6)
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set blk^[0] = (x7 + x1) >> 8
    set blk^[1] = (x3 + x2) >> 8
    set blk^[2] = (x0 + x4) >> 8
    set blk^[3] = (x8 + x6) >> 8
    set blk^[4] = (x8 - x6) >> 8
    set blk^[5] = (x0 - x4) >> 8
    set blk^[6] = (x3 - x2) >> 8
    set blk^[7] = (x7 - x1) >> 8

-- clamp x to [0:255]
fun ClampU8(x s32) u8:
    cond:
        case x < 0:
            return 0
        case x >= 0xff:
            return 0xff
        case true:
            return as(x, u8)


fun ColIDCT(blk ^[8*8]s32, out slice!(u8), stride uint) void:
    let! x1 = blk^[8*4] << 8
    let! x2 = blk^[8*6]
    let! x3 = blk^[8*2]
    let! x4 = blk^[8*1]
    let! x5 = blk^[8*7]
    let! x6 = blk^[8*5]
    let! x7 = blk^[8*3]
    if (x1 or x2 or x3 or x4 or x5 or x6 or x7) == 0:
        let t = ClampU8(((blk^[0] + 32) >> 6) + 128)
        for i = 0, 8_u32, 1:
            set out[i * 8] = t
        return
    let! x0 = (blk^[0] << 8) + 8192
    let! x8 = (x4 + x5) * W7 + 4
    set x4 = (x8 + x4 * (W1 - W7)) >> 3
    set x5 = (x8 - x5 * (W1 + W7)) >> 3
    set x8 = (x6 + x7) * W3 + 4
    set x6 = (x8 - x6 * (W3 - W5)) >> 3
    set x7 = (x8 - x7 * (W3 + W5)) >> 3
    set x8 = x0 + x1
    set x0 -= x1
    set x1 = (x3 + x2) * W6 + 4
    set x2 = (x1 - x2 * (W2 + W6)) >> 3
    set x3 = (x1 + x3 * (W2 - W6)) >> 3
    set x1 = x4 + x6
    set x4 -= x6
    set x6 = x5 + x7
    set x5 -= x7
    set x7 = x8 + x3
    set x8 -= x3
    set x3 = x0 + x2
    set x0 -= x2
    set x2 = ((x4 + x5) * 181 + 128) >> 8
    set x4 = ((x4 - x5) * 181 + 128) >> 8
    set out[0 * stride] = ClampU8(((x7 + x1) >> 14) + 128)
    set out[1 * stride] = ClampU8(((x3 + x2) >> 14) + 128)
    set out[2 * stride] = ClampU8(((x0 + x4) >> 14) + 128)
    set out[3 * stride] = ClampU8(((x8 + x6) >> 14) + 128)
    set out[4 * stride] = ClampU8(((x8 - x6) >> 14) + 128)
    set out[5 * stride] = ClampU8(((x0 - x4) >> 14) + 128)
    set out[6 * stride] = ClampU8(((x3 - x2) >> 14) + 128)
    set out[7 * stride] = ClampU8(((x7 - x1) >> 14) + 128)



pub rec BitStream:
    buf slice(u8)
    offset uint
    -- contains the next up to 8 bits from the stream
    -- the exact number is bits_count
    bits_cache u8
    bits_count u8
    -- end-of-stream flag - once set it will not be cleared
    eos bool

pub fun GetNextBit(bs ^!BitStream) u16:
    let! bits_count u8 = bs^.bits_count
    let! bits_cache u8 = bs^.bits_cache
    if bits_count == 0:
        if bs^.offset == len(bs^.buf):
            set bs^.eos = true
            return 0
        set bits_cache = bs^.buf[bs^.offset]
        set bs^.offset += 1
        set bits_count = 8
        if bits_cache == 0xff:
            if bs^.offset == len(bs^.buf):
                set bs^.eos = true
                return 0
            let zeros = bs^.buf[bs^.offset]
            if zeros != 0:
                set bs^.eos = true
                return 0
            set bs^.offset += 1

    let out = as(bits_cache and 1, u16)
    set bits_cache >>= 1
    set bits_count -= 1
    set bs^.bits_count = bits_count
    set bs^.bits_cache = bits_cache
    return out


rec AppInfo:
    version_major u8
    version_minor u8
    units u8
    density_x u16
    density_y u16
    thumbnail_w u8
    thumbnail_h u8

rec Component:
    cid u8
    ssx u32
    ssy u32
    qtsel u8

    -- image dimensions in pixels
    width u32
    height u32
    stride u32
    dctabsel u8
    actabsel u8

rec FrameInfo:
    width u32
    height u32
    ncomp u8

    -- macro block dimensions in pixels (e.g. 8x8)
    mbsizex u32
    mbsizey u32
    -- image dimension measure in macro blocks
    mbwidth u32
    mbheight u32

    comp [3]Component




pub @wrapped type Success = void
pub global SuccessVal = wrap_as(void, Success)

pub @wrapped type CorruptionError = void
pub global CorruptionErrorVal = wrap_as(void, CorruptionError)

pub @wrapped type UnsupportedError = void
pub global UnsupportedErrorVal = wrap_as(void, UnsupportedError)






fun div_roundup(a u32, b u32) u32:
    return (a + b -1) / b

fun DecodeHufmanTable(chunk slice(u8))
    union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    while len(data) > 0:
        let kind = BS::FrontU8Unchecked(&!data)
        if kind and 0xec != 0:
            return CorruptionErrorVal
        if kind and 0x02 != 0:
            return UnsupportedErrorVal
        -- combined DC/AC + tableid value
        let pos u32 = ((as(kind, u32) and 0x1f) >> 3) or (as(kind, u32) and 1)
        let counts = BS::FrontSliceUnchecked(&!data, 16)
        let! total = 0_uint
        for codelen = 0, 16_s32, 1:
            set total += as(counts[codelen], uint)
        if len(data) < total:
            return  BS::OutOfBoundsErrorVal
        debug#("Hufman total codes[", pos, "]: ", total, "\n")
        -- TBD
        do BS::SkipUnchecked(&!data, total)
    return SuccessVal

fun DecodeQuantizationTable(chunk slice(u8),  qtab ^![4][64]u8)
    union(u8, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    let! qtavail u8 = 0
    while len(data) >= 65:
        let t = data[0]
        if t and 0xfc != 0:
            return CorruptionErrorVal
        debug#("processing qt: ", t, "\n")
        set qtavail or= 1 << t
        for i = 0, 64_u32, 1:
            set qtab^[t][i] = data[i + 1]
        do BS::SkipUnchecked(&!data, 65)
    if len(data) != 0:
        return CorruptionErrorVal
    return qtavail

fun DecodeRestartInterval(chunk slice(u8))
      union(u16, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet interval u16 = BS::FrontBeU16(&!data), err:
        return err
    debug#("restart interval: ", interval, "\n")
    return interval

fun DecodeAppInfo(chunk slice(u8), app_info ^!AppInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    if len(data) < 14:
        return CorruptionErrorVal
    if data[0] != 'J' || data[1] != 'F' || data[2] != 'I'  || data[3] != 'F' || data[4] != 0:
        return CorruptionErrorVal
    do BS::SkipUnchecked(&!data, 5)
    set app_info^.version_major = BS::FrontU8Unchecked(&!data)
    set app_info^.version_minor = BS::FrontU8Unchecked(&!data)
    set app_info^.units = BS::FrontU8Unchecked(&!data)
    set app_info^.density_x = BS::FrontBeU16Unchecked(&!data)
    set app_info^.density_y = BS::FrontBeU16Unchecked(&!data)
    set app_info^.thumbnail_w = BS::FrontU8Unchecked(&!data)
    set app_info^.thumbnail_h = BS::FrontU8Unchecked(&!data)
    debug#("AppInfo: ", app_info^.version_major, ".", app_info^.version_minor, "\n")
    return SuccessVal

fun DecodeStartOfFrame(chunk slice(u8), out ^!FrameInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! data = chunk
    trylet format u8 = BS::FrontU8(&!data), err:
        return err
    if format != 8:
        debug#("unsupported format: ", format, "\n")
        return UnsupportedErrorVal
    trylet height u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.height = as(height, u32)
    trylet width u16 = BS::FrontBeU16(&!data), err:
            return err
    set out^.width = as(width, u32)
    trylet ncomp u8  = BS::FrontU8(&!data), err:
            return err
    set out^.ncomp = ncomp
    if ncomp != 1 &&  ncomp != 3:
        debug#("unsupported ncomp: ", ncomp, "\n")
        return UnsupportedErrorVal

    debug#("frame: ", width, "x", height, " ncomp: ", ncomp, "\n")
    let! ssxmax u32 = 0
    let! ssymax u32 = 0
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        tryset comp^.cid = BS::FrontU8(&!data), err:
            return err

        trylet ss u8 = BS::FrontU8(&!data), err:
            return err
        let ssx = as(ss >> 4, u32)
        let ssy = as(ss and 0xf, u32)
        -- ssy must be a power of two
        if ssx == 0 || ssy == 0 || ssy and (ssy - 1) != 0:
            debug#("bad ss: ", ssx, "x", ssy, "\n")
            return CorruptionErrorVal

         debug#("comp: ", i, " ", comp^.cid, " ", ssx, "x", ssy, "\n")

        set comp^.ssx = ssx
        set comp^.ssy = ssy
        set ssxmax max= ssx
        set ssymax max= ssy

        trylet! qtsel u8 = BS::FrontU8(&!data), err:
            return err
        if qtsel and 0xfc!= 0:
            debug#("bad qtsel: ", qtsel, "\n")
            return CorruptionErrorVal
        set comp^.qtsel = qtsel

    if ncomp == 1:
        set ssxmax = 1
        set ssymax = 1
        set out^.comp[0].ssx = 1
        set out^.comp[0].ssy = 1

    let mbsizex  u32 = as(ssxmax, u32) * 8
    let mbsizey  u32 = as(ssymax, u32) * 8

    set out^.mbsizex = mbsizex
    set out^.mbsizey = mbsizey
    set out^.mbwidth = div_roundup(out^.width, mbsizex)
    set out^.mbheight = div_roundup(out^.height, mbsizey)
    debug#("mbsize: ", mbsizex, "x", mbsizey,  " mbdim: ", out^.mbwidth, "x", out^.mbheight, "\n")
    for i = 0, ncomp, 1:
        let comp ^!Component = &!(out^.comp[i])
        set comp^.width = div_roundup(out^.width * comp^.ssx, ssxmax)
        set comp^.height = div_roundup(out^.height * comp^.ssy, ssymax)
        set comp^.stride = out^.mbwidth * comp^.ssx * 8
        if comp^.width < 3 && comp^.ssx != ssxmax:
            debug#("bad width: ", comp^.width, "\n")
            return CorruptionErrorVal
        if comp^.height < 3 && comp^.ssy != ssymax:
            debug#("bad height: ", comp^.height, "\n")
            return CorruptionErrorVal
        debug#("comp: ", i, " ", comp^.width, "x", comp^.height, " stride:", comp^.stride, "\n")

    return SuccessVal

fun DecodeScan(chunk slice(u8), frame_info ^!FrameInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
   @ref let! data = chunk
   trylet ncomp u8  = BS::FrontU8(&!data), err:
            return err
   if ncomp != frame_info^.ncomp:
        return UnsupportedErrorVal

   for i = 0, ncomp, 1:
        if len(data) < 2:
            return  BS::OutOfBoundsErrorVal
        let comp ^!Component = &!(frame_info^.comp[i])
        if  data[0] != comp^.cid:
            return CorruptionErrorVal
        let tabsel = data[1]
        if tabsel and 0xee != 0:
             return CorruptionErrorVal
        set comp^.dctabsel = tabsel >> 4
        set comp^.actabsel = tabsel and 1 or 2
        debug#("tabsel[", comp^.cid,"]: ", tabsel, "\n")
        do BS::SkipUnchecked(&!data, 2)
        if len(data) < 3:
            return  BS::OutOfBoundsErrorVal

    if data[0] != 0 || data[1] != 63 || data[2] != 0:
        return UnsupportedErrorVal
    do BS::SkipUnchecked(&!data, 3)
   return SuccessVal



fun  DecodeBlock(bs ^!BitStream)
    union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    return SuccessVal

fun DecodeMacroBlocksHuffman(chunk slice(u8), frame_info ^FrameInfo)
       union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    @ref let! bs = BitStream{chunk}
    let num_macro_blocks = frame_info^.mbwidth * frame_info^.mbheight
    for m = 0, num_macro_blocks, 1:
        for c = 0, frame_info^.ncomp, 1:
            let comp ^Component = &(frame_info^.comp[c])
            for y = 0, comp^.ssy, 1:
                for x = 0, comp^.ssx, 1:
                    trylet dummy Success = DecodeBlock(&!bs), err:
                        return err


    return SuccessVal

pub fun DecodeImage(a_data slice(u8))
        union(Success, CorruptionError, UnsupportedError, BS::OutOfBoundsError):
    debug#("DecodeImage: ", len(a_data), "\n")
    @ref let! app_info AppInfo = undef
    @ref let! frame_info FrameInfo = undef
    @ref let! quantization_tab [4][64]u8 = undef
    let! qt_avail_bits u8 = 0
    let! restart_interval u16 = 0
    @ref let! data = a_data
    trylet magic u16 = BS::FrontBeU16(&!data), err:
        return err
    if magic != 0xffd8:
        debug#("bad magic: ", wrap_as(magic, fmt::u16_hex), "\n")
        return  CorruptionErrorVal

    while true:
        trylet chunk_kind u16 = BS::FrontBeU16(&!data), err:
            return err
        trylet chunk_length u16 = BS::FrontBeU16(&!data), err:
            return err

        debug#("CHUNK: ", wrap_as(chunk_kind, fmt::u16_hex), " ", chunk_length, "\n")
        trylet chunk_slice slice(u8) = BS::FrontSlice(&!data, as(chunk_length - 2, uint)), err:
            return err
        cond:
            case chunk_kind == 0xffe0:
                trylet dummy Success = DecodeAppInfo(chunk_slice, &!app_info), err:
                    return err
            case chunk_kind == 0xffc0:
                trylet dummy Success = DecodeStartOfFrame(chunk_slice, &!frame_info), err:
                    return err
            case chunk_kind == 0xffc4:
                trylet dummy Success = DecodeHufmanTable(chunk_slice), err:
                    return err
            case chunk_kind == 0xffdb:
                tryset qt_avail_bits = DecodeQuantizationTable(chunk_slice, &!quantization_tab), err:
                    return err
            case chunk_kind == 0xffdd:
                tryset restart_interval = DecodeRestartInterval(chunk_slice), err:
                    return err
            case chunk_kind == 0xffda:
                -- start of scan chunk, huffman encoded image data follows
                trylet dummy Success = DecodeScan(chunk_slice, &!frame_info), err:
                    return err
            case chunk_kind == 0xfffe:
                debug#("chunk ignored\n")
            case chunk_kind and 0xfff0 == 0xffe0:
                debug#("chunk ignored\n")
            case true:
                return UnsupportedErrorVal

    debug#("DecodeImage complete\n")
    return SuccessVal